//! Functional test for delay module

#![forbid(unsafe_code)]
use miner::delay;

#[test]
fn test_do_delay() {
    // use a test pre image and a 100 difficulty
    let proof = delay::do_delay(b"test preimage", 100);

    // print to copy/paste the correct_proof string below.
    println!("proof:\n{:?}", hex::encode(&proof));

    let correct_proof = hex::decode("0043737990fab525c79472ba75b75b11296714304cdd9421eae2b8cf03c36274c2f6b6fd4892971fa428e2cff640237c7ef9b1a0f129e938b351799ce88ef85cd50d2e1cfea84bd9ff52687a632f6187b2718629eefe30242a9d7cc8a6e68e922eb37cc1c1f4ef6e16534e8326c9f1273d3176c49dcfde2782a0bcb4332c0c777383dad319fd2ea100a460f7e557c432240a34b5b80fbae8adc1f0467e3e38f94a9c972a7c756b37f8b0a4e917efe9f384624d631015327d66680a58bac9d25cb1af7ab7b1968681e34aadb49680001dc92e1b73e10ca2866681361f4824acc13d51cec8ca84513e6f3570b294543d3268d7a6ad9dd6a3cefe0410e11d7c3d05670024b0c05a9f8ba5dbf2c2fa3836fa5ba213e8031ae85b7ae74ed03ec7d1bca7313b7dae15915f4333a3b69bf81c1066477aa773da7b6eb958337c5c0880d53ec656b4db1e9e97e487e3f333af315b57b8cdf7d02dc12c9b625d65f12ed6139d0562b400a5c2b94f19a0056a6e7dfcce6b92fa0862035c2c889452f50b92de3fb067eed3c13a2d7ec19f0270cf56d501f437f61f6e311152ce2b9f4aee21ebec5b6231a669ec372f64baa3b19bbc51e6e8f3bd26f305206c1c0d63b0f6fdb715b15155d747f5a517eeb0423cce5efbc4485106aba485a4adfc037d48df4dd2104e5c3944511f6b2ddb47426dba8a5070042827c0cebd1e0b57695d8afa0369dd3d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001").unwrap();

    //println!("decoded:\n{:?}", correct_proof);

    assert_eq!(proof, correct_proof, "proof is incorrect");
}
